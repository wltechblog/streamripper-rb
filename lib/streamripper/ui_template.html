<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StreamRipper - RTSP Stream Analyzer</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css">
    <link href="https://fonts.googleapis.com/css2?family=Anonymous+Pro:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <style>
    body {
    min-height: 100vh
    font-family: 'Anonymous Pro', monospace;
    }

    .input-section {
    padding: 1.5rem;
    border-radius: 0.5rem;
    margin-bottom: 2rem;
    }

    .scan-thumbnail {
    width: 150px;
    height: 100px;
    object-fit: cover;
    border-radius: 0.25rem;
    cursor: pointer;
    border: 3px solid rgba(255,255,255,0.3);
    transition: border-color 0.2s;
    }

    .scan-thumbnail:hover {
    border-color: rgba(255,255,255,0.6);
    }

    .scan-controls {
    position: absolute;
    top: 2rem;
    right: 2rem;
    display: flex;
    gap: 0.625rem;
    align-items: center;
    width: 200px;
    justify-content: flex-end;
    }

    .reparse-status {
    font-weight: bold;
    font-size: 0.8125rem;
    white-space: nowrap;
    }

    .frame-type {
    display: inline-block;
    padding: 0.25rem 0.5rem;
    border-radius: 0.25rem;
    font-size: 0.85rem;
    font-weight: 600;
    color: white;
    }

    .frame-type.i-frame { background: #1b5e20; }
    .frame-type.p-frame { background: #81c784; }
    .frame-type.fragment { background: #9c27b0; }
    .frame-type.sps { background: #ffd93d; color: #333; }
    .frame-type.pps { background: #ffd93d; color: #333; }
    .frame-type.audio { background: #1976d2; }
    .frame-type.unknown { background: #d32f2f; }

    .hex-dump {
    background: #1e1e1e;
    color: #00ff00;
    font-family: 'Courier New', monospace;
    font-size: 15px;
    padding: 15px;
    border-radius: 4px;
    overflow-x: auto;
    line-height: 1.6;
    white-space: pre;
    }

    #previousScans {
    padding: 1.25rem;
    border-radius: 0.5rem;
    margin-bottom: 1.25rem;
    }
    </style>
  </head>
  <body class="py-5">
    <header class="text-center">
      <h1><a href="/" class="text-decoration-none" title="StreamRipper"><img src="logo.png" alt="StreamRipper Logo" class="img-fluid"></a></h1>
      <p class="text-white-50">Real-time RTSP Stream Analysis & Forensics</p>
    </header>

    <div class="container p-4">
      <div id="errorMsg" class="alert alert-danger d-none" role="alert"></div>

      <div class="alert alert-secondary">
        <div class="row g-2">
          <div class="col-md-6">
            <label for="rtspUrl">RTSP URL</label>
            <input type="text" id="rtspUrl" class="form-control" placeholder="RTSP URL (e.g., rtsp://user:pass@host/ch0)" value="rtsp://thingino:thingino@192.168.88.31/ch0">
          </div>
          <div class="col-md-2">
            <label for="duration">Duration</label>
            <div class="input-group mb-3">
              <input type="number" id="duration" class="form-control text-end" placeholder="Duration (seconds)" value="5" min="1" max="300">
              <span class="input-group-text">sec</span>
            </div>
          </div>
          <div class="col-md-2">
            <button onclick="startCapture()" class="btn btn-primary">Start Capture</button>
          </div>
        </div>
      </div>

      <!-- Capture Modal -->
      <div id="captureModal" class="modal fade" tabindex="-1" role="dialog" aria-labelledby="captureModalLabel" aria-hidden="true" data-bs-backdrop="static" data-bs-keyboard="false">
        <div class="modal-dialog modal-dialog-centered">
          <div class="modal-content">
            <div class="modal-body text-center py-5">
              <div class="spinner-border text-primary mb-4" role="status" style="width: 3rem; height: 3rem;">
                <span class="visually-hidden">Loading...</span>
              </div>
              <h5 class="modal-title mb-3" id="captureModalLabel">Capturing Stream...</h5>
              <div class="fs-2 fw-bold text-primary font-monospace mb-3" id="countdownDisplay">0:00</div>
              <p class="text-muted small">Please wait while the stream is being captured and analyzed</p>
            </div>
          </div>
        </div>
      </div>

      <div id="results" class="d-none">

        <div id="scanTitle" class="alert alert-info d-flex gap-4 align-items-start">
          <div class="flex-shrink-0">
            <img id="scanThumbnail" src="noimage.png" class="scan-thumbnail" onclick="openVideoModal()" title="Click to play video">
          </div>
          <div class="flex-grow-1">
            <h2 class="fs-3">Scan Results</h2>

            <div class="row g-3 mb-3">
              <div class="col">
                <h5 class="text-white-50 mb-0">Stream</h5>
                <div class="fw-bold fs-5" id="scanStream">-</div>
              </div>
              <div class="col">
                <h5 class="text-white-50 mb-0">Endpoint</h5>
                <div class="fw-bold fs-5" id="scanEndpoint">-</div>
              </div>
              <div class="col">
                <h5 class="text-white-50 mb-0">Scan Time</h5>
                <div class="fw-bold fs-5" id="scanTime">-</div>
              </div>
            </div>

            <div class="row g-3">
              <div class="col">
                <h5 class="text-white-50 mb-0">Total Frames</h5>
                <div class="fs-3 fw-bold" id="frameCount">0</div>
              </div>
              <div class="col">
                <h5 class="text-white-50 mb-0">Total Packets</h5>
                <div class="fs-3 fw-bold" id="packetCount">0</div>
              </div>
              <div class="col">
                <h5 class="text-white-50 mb-0">Duration</h5>
                <div class="fs-3 fw-bold" id="captureDuration">0s</div>
              </div>
              <div class="col">
                <h5 class="text-white-50 mb-0">Frame Rate</h5>
                <div class="fs-3 fw-bold" id="frameRate">0 fps</div>
              </div>
            </div>

          </div>

          <div class="scan-controls">
            <span id="reparseStatus" class="reparse-status d-none"></span>
            <button onclick="reparseData()" class="btn btn-warning">Reparse</button>
          </div>
        </div>

        <h2 class="mt-5 mb-4">Analysis Charts</h2>
        <div class="row g-4 mb-5">
          <div class="col-lg-6">
            <div class="card">
              <div class="card-body">
                <h5 class="card-title">Time Deviation (µs)</h5>
                <canvas id="deviationChart"></canvas>
              </div>
            </div>
          </div>
          <div class="col-lg-6">
            <div class="card">
              <div class="card-body">
                <h5 class="card-title">Packet Sizes (bytes)</h5>
                <canvas id="packetSizeChart"></canvas>
              </div>
            </div>
          </div>
        </div>

        <div class="row g-4 mb-5">
          <div class="col-12">
            <div class="card">
              <div class="card-body">
                <h5 class="card-title">Packet Flow Over Time</h5>
                <p class="text-muted small mb-3">Shows packet arrival patterns - bursts indicate congestion or frame boundaries</p>
                <canvas id="packetFlowChart"></canvas>
              </div>
            </div>
          </div>
        </div>

        <h2 class="mt-5 mb-3">Frame Summary</h2>
        <div class="table-responsive">
          <table class="table table-striped table-hover">
            <thead>
              <tr>
                <th>Frame #</th>
                <th>Packet Range</th>
                <th>Type</th>
                <th class="text-end">Size</th>
                <th class="text-end">RTP TS</th>
                <th class="text-end">Deviation</th>
              </tr>
            </thead>
            <tbody id="framesBody"></tbody>
          </table>
        </div>

      </div>

      <div id="previousScans" class="d-none mt-5 pt-5 border-top">
        <h2 class="mb-4">Previous Scans</h2>
        <div id="scansList" class="row g-3"></div>
      </div>
    </div>

    <!-- Hex Modal -->
    <div id="hexModal" class="modal fade" tabindex="-1" role="dialog" aria-labelledby="hexModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-lg modal-dialog-scrollable">
        <div class="modal-content">
          <div class="modal-header">
            <h1 class="modal-title fs-5" id="modalTitle">Frame Hex Dump</h1>
            <div class="d-flex gap-4 align-items-center">
              <button type="button" class="btn btn-link p-0 text-decoration-none" id="copyHexBtn" onclick="copyHexToClipboard()" title="Copy hex to clipboard" aria-label="Copy">
                <i class="bi bi-clipboard"></i>
              </button>
              <button type="button" class="btn btn-link p-0 text-decoration-none" id="downloadFrameBtn" onclick="downloadFrame()" title="Download frame binary" aria-label="Download">
                <i class="bi bi-download"></i>
              </button>
              <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
          </div>
          <div class="modal-body">
            <div class="hex-dump" id="hexContent"></div>
          </div>
        </div>
      </div>
    </div>

    <!-- Video Modal -->
    <div id="videoModal" class="modal fade" tabindex="-1" role="dialog" aria-labelledby="videoModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-xl modal-dialog-centered">
        <div class="modal-content">
          <div class="modal-header">
            <h1 class="modal-title fs-5" id="videoModalLabel">Video Playback</h1>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            <video id="streamVideo" width="100%" height="auto" controls style="border-radius: 0.25rem; background: #000;">
              <source id="videoSource" src="" type="video/mp4">
              Your browser does not support the video tag.
            </video>
          </div>
        </div>
      </div>
    </div>

    <script>
    let captureData = null;
    let currentFrame = null;
    let downloadInProgress = false;
    let countdownInterval = null;
    let deviationChart = null;
    let packetSizeChart = null;
    let packetFlowChart = null;

    async function startCapture() {
      const rtspUrl = document.getElementById('rtspUrl').value;
      const duration = parseInt(document.getElementById('duration').value);

      if (!rtspUrl) {
        showError('Please enter an RTSP URL');
        return;
      }

      // Show capture modal using Bootstrap API
      const captureModalElement = document.getElementById('captureModal');
      const captureModalInstance = new bootstrap.Modal(captureModalElement);
      captureModalInstance.show();
      document.getElementById('results').classList.add('d-none');
      document.getElementById('errorMsg').classList.add('d-none');

      // Preset the countdown display with initial value
      const countdownDisplay = document.getElementById('countdownDisplay');
      const minutes = Math.floor(duration / 60);
      const seconds = duration % 60;
      countdownDisplay.textContent = minutes + ':' + (seconds < 10 ? '0' : '') + seconds;

      // Start countdown
      let remainingTime = duration;

      countdownInterval = setInterval(() => {
        remainingTime--;

        // Ensure remainingTime doesn't go below 0
        if (remainingTime < 0) {
          remainingTime = 0;
        }

        const minutes = Math.floor(remainingTime / 60);
        const seconds = remainingTime % 60;
        countdownDisplay.textContent = minutes + ':' + (seconds < 10 ? '0' : '') + seconds;

        if (remainingTime <= 0) {
          clearInterval(countdownInterval);
          countdownInterval = null;
        }
      }, 1000);

      try {
        const response = await fetch('/api/capture', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ rtsp_url: rtspUrl, duration: duration })
        });

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Capture failed');
        }

        captureData = await response.json();

        // Extract host and scan_id from the capture response
        if (captureData.host && captureData.scan_id) {
          // Update URL to the new scan
          const newUrl = '?host=' + encodeURIComponent(captureData.host) +
            '&scan_id=' + encodeURIComponent(captureData.scan_id);
          window.history.pushState({ host: captureData.host, scan_id: captureData.scan_id }, '', newUrl);
        }

        displayResults(captureData);
      } catch (error) {
        showError(error.message);
      } finally {
        // Clear countdown interval
        if (countdownInterval) {
          clearInterval(countdownInterval);
          countdownInterval = null;
        }

        // Hide capture modal using Bootstrap API
        const captureModalElement = document.getElementById('captureModal');
        const captureModalInstance = bootstrap.Modal.getInstance(captureModalElement);
        if (captureModalInstance) {
          captureModalInstance.hide();
        }
        document.getElementById('results').classList.remove('d-none');
      }
    }

    function displayResults(data) {
      // Populate scan title
      const scanIdParts = data.scan_id.split('_');
      const scanDate = scanIdParts[0];
      const scanTime = scanIdParts[1];
      const formattedDate = scanDate.substring(0, 4) + '-' + scanDate.substring(4, 6) + '-' + scanDate.substring(6, 8);
      const formattedTime = scanTime.substring(0, 2) + ':' + scanTime.substring(2, 4) + ':' + scanTime.substring(4, 6);

      // Extract IP and endpoint from host
      const hostParts = data.host.split('_');
      const ip = hostParts.slice(0, 4).join('.');
      const endpoint = '/' + hostParts.slice(4).join('/');

      document.getElementById('scanStream').textContent = ip;
      document.getElementById('scanEndpoint').textContent = endpoint;
      document.getElementById('scanTime').textContent = formattedDate + ' ' + formattedTime;

      // Set thumbnail
      const thumbnailUrl = '/thumbnails/' + encodeURIComponent(data.host) + '/' + encodeURIComponent(data.scan_id) + '/thumbnail.jpg';
      const thumbnail = document.getElementById('scanThumbnail');
      thumbnail.src = thumbnailUrl;
      thumbnail.onerror = () => {
        thumbnail.classList.add('d-none');
      };

      document.getElementById('frameCount').textContent = data.frame_count;
      document.getElementById('packetCount').textContent = data.packet_count;
      document.getElementById('captureDuration').textContent = data.duration + 's';
      document.getElementById('frameRate').textContent = (data.frame_count / data.duration).toFixed(2) + ' fps';

      const tbody = document.getElementById('framesBody');
      tbody.innerHTML = '';

      data.frames.forEach(frame => {
        const row = document.createElement('tr');
        const typeClass = frame.frame_type.toLowerCase().replace('-', '-');
        const packetRange = frame.first_packet > 0 ? `${frame.first_packet}-${frame.last_packet}` : '-';
        row.innerHTML = `
<td>${frame.frame_number}</td>
<td>${packetRange}</td>
<td><span class="frame-type ${typeClass}">${frame.frame_type}</span></td>
<td class="text-end">${frame.total_size} bytes</td>
<td class="text-end">${frame.rtp_timestamp}</td>
<td class="text-end">${frame.deviation} µs</td>
`;
        row.onclick = () => showHexDump(frame);
        tbody.appendChild(row);
      });

      // Render charts
      renderDeviationChart(data.frames);
      renderPacketSizeChart(data.frames);
      if (data.packet_times) {
        renderPacketFlowChart(data.packet_times);
      }

      // Load video if available
      if (data.host && data.scan_id) {
        loadVideo(data.host, data.scan_id);
      }

      document.getElementById('results').classList.remove('d-none');
      showPreviousScansSection();

      // Scroll to scan title
      document.getElementById('scanTitle').scrollIntoView({ behavior: 'smooth', block: 'start' });
    }

    function loadVideo(host, scanId) {
      const videoSource = document.getElementById('videoSource');
      const videoElement = document.getElementById('streamVideo');

      if (!videoSource || !videoElement) {
        console.error('Video elements not found');
        return;
      }

      const mp4Url = '/logs/streams/' + encodeURIComponent(host) + '/' + encodeURIComponent(scanId) + '/stream.mp4';

      console.log('Loading video from:', mp4Url);
      videoSource.src = mp4Url;
      videoElement.load();
    }

    function renderDeviationChart(frames) {
      // Destroy existing chart if it exists
      if (deviationChart) {
        deviationChart.destroy();
        deviationChart = null;
      }

      const ctx = document.getElementById('deviationChart').getContext('2d');

      const labels = frames.map(f => 'Frame ' + f.frame_number);
      const deviations = frames.map(f => f.deviation);

      // Determine color based on deviation value
      const colors = deviations.map(d => {
        if (d === 0) return '#4CAF50'; // Green for 0
        if (d > 0) return '#FF9800'; // Orange for positive
        return '#F44336'; // Red for negative
      });

      deviationChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Time Deviation (µs)',
            data: deviations,
            backgroundColor: colors,
            borderColor: colors,
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          plugins: {
            legend: {
              display: true,
              position: 'top'
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Deviation (µs)'
              }
            }
          }
        }
      });
    }

    function renderPacketSizeChart(frames) {
      // Destroy existing chart if it exists
      if (packetSizeChart) {
        packetSizeChart.destroy();
        packetSizeChart = null;
      }

      const ctx = document.getElementById('packetSizeChart').getContext('2d');

      const labels = frames.map(f => 'Frame ' + f.frame_number);
      const sizes = frames.map(f => f.total_size);

      packetSizeChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Packet Size (bytes)',
            data: sizes,
            borderColor: '#667eea',
            backgroundColor: 'rgba(102, 126, 234, 0.1)',
            borderWidth: 2,
            fill: true,
            tension: 0.4,
            pointBackgroundColor: '#667eea',
            pointBorderColor: '#fff',
            pointBorderWidth: 2,
            pointRadius: 4,
            pointHoverRadius: 6
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          plugins: {
            legend: {
              display: true,
              position: 'top'
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Size (bytes)'
              }
            }
          }
        }
      });
    }

    function renderPacketFlowChart(packetTimes) {
      // Destroy existing chart if it exists
      if (packetFlowChart) {
        packetFlowChart.destroy();
        packetFlowChart = null;
      }

      const ctx = document.getElementById('packetFlowChart').getContext('2d');

      // Group packets into 100ms buckets to show burst patterns
      const bucketSize = 100; // milliseconds
      const maxTime = Math.max(...packetTimes.map(p => p.time_offset_ms));
      const numBuckets = Math.ceil(maxTime / bucketSize);

      const buckets = Array(numBuckets).fill(0);
      const bucketLabels = [];

      for (let i = 0; i < numBuckets; i++) {
        bucketLabels.push((i * bucketSize) + '-' + ((i + 1) * bucketSize) + 'ms');
      }

      // Count packets in each bucket
      packetTimes.forEach(p => {
        const bucketIndex = Math.floor(p.time_offset_ms / bucketSize);
        if (bucketIndex < numBuckets) {
          buckets[bucketIndex]++;
        }
      });

      packetFlowChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: bucketLabels,
          datasets: [{
            label: 'Packets per 100ms',
            data: buckets,
            backgroundColor: 'rgba(102, 126, 234, 0.6)',
            borderColor: '#667eea',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          plugins: {
            legend: {
              display: true,
              position: 'top'
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Packet Count'
              }
            },
            x: {
              title: {
                display: true,
                text: 'Time Window'
              }
            }
          }
        }
      });
    }

    async function showHexDump(frame) {
      try {
        // Store current frame for download
        currentFrame = frame;

        const response = await fetch('/api/frame-hex?frame=' + encodeURIComponent(frame.payload));
        const data = await response.json();
        document.getElementById('hexContent').textContent = data.hex;

        // Update modal header with frame info
        const modalTitle = document.getElementById('modalTitle');
        if (modalTitle) {
          modalTitle.textContent = 'Frame ' + frame.frame_number + ' - ' + frame.frame_type + ' (' + frame.total_size + ' bytes)';
        }

        // Use Bootstrap modal API
        const hexModalElement = document.getElementById('hexModal');
        const hexModal = new bootstrap.Modal(hexModalElement);
        hexModal.show();
      } catch (error) {
        showError('Failed to load hex dump: ' + error.message);
      }
    }

    function copyHexToClipboard() {
      const hexContent = document.getElementById('hexContent');
      if (!hexContent || !hexContent.textContent) {
        showError('No hex content to copy');
        return;
      }

      try {
        navigator.clipboard.writeText(hexContent.textContent).then(() => {
          // Show feedback
          const copyBtn = document.getElementById('copyHexBtn');
          const originalHTML = copyBtn.innerHTML;
          copyBtn.innerHTML = '<i class="bi bi-check-circle"></i>';
          copyBtn.classList.add('text-success');

          setTimeout(() => {
            copyBtn.innerHTML = originalHTML;
            copyBtn.classList.remove('text-success');
          }, 2000);
        }).catch(err => {
            showError('Failed to copy to clipboard: ' + err.message);
          });
      } catch (error) {
        showError('Failed to copy: ' + error.message);
      }
    }

    function downloadFrame() {
      // Prevent double downloads with debounce
      if (downloadInProgress) {
        return;
      }

      if (!currentFrame) {
        showError('No frame selected');
        return;
      }

      try {
        // Set download in progress flag
        downloadInProgress = true;
        const downloadBtn = document.getElementById('downloadFrameBtn');
        const originalHTML = downloadBtn.innerHTML;
        downloadBtn.innerHTML = '<i class="bi bi-hourglass-split"></i>';
        downloadBtn.disabled = true;

        // Decode base64 payload to binary
        const binaryString = atob(currentFrame.payload);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }

        // Create blob and download
        const blob = new Blob([bytes], { type: 'application/octet-stream' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'frame_' + currentFrame.frame_number.toString().padStart(5, '0') + '_' + currentFrame.frame_type.toLowerCase() + '.bin';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);

        // Reset button after download completes
        setTimeout(() => {
          downloadBtn.innerHTML = originalHTML;
          downloadBtn.disabled = false;
          downloadInProgress = false;
        }, 1000);
      } catch (error) {
        showError('Failed to download frame: ' + error.message);
        // Reset on error
        downloadInProgress = false;
        downloadBtn.innerHTML = originalHTML;
        downloadBtn.disabled = false;
      }
    }

    function closeHexModal() {
      // Use Bootstrap modal API to close
      const hexModalElement = document.getElementById('hexModal');
      const hexModal = bootstrap.Modal.getInstance(hexModalElement);
      if (hexModal) {
        hexModal.hide();
      }
    }

    function openVideoModal() {
      // Use Bootstrap modal API to open
      const videoModalElement = document.getElementById('videoModal');
      const videoModal = new bootstrap.Modal(videoModalElement);
      videoModal.show();
    }

    function closeVideoModal() {
      // Use Bootstrap modal API to close
      const videoModalElement = document.getElementById('videoModal');
      const videoModal = bootstrap.Modal.getInstance(videoModalElement);
      if (videoModal) {
        videoModal.hide();
      }
    }

    function showError(message) {
      const errorDiv = document.getElementById('errorMsg');
      errorDiv.textContent = message;
      errorDiv.classList.remove('d-none');
    }

    // Load previous scans on page load
    document.addEventListener('DOMContentLoaded', function() {
      loadPreviousScans();

      // Check if URL has scan parameters
      const params = new URLSearchParams(window.location.search);
      const host = params.get('host');
      const scanId = params.get('scan_id');

      if (host && scanId) {
        // Load the scan from URL parameters
        loadScanData(host, scanId);
      }
    });

    async function loadPreviousScans() {
      try {
        const response = await fetch('/api/list-scans');
        const data = await response.json();

        if (data.scans && data.scans.length > 0) {
          displayPreviousScans(data.scans);
        }
      } catch (error) {
        console.error('Failed to load previous scans:', error);
      }
    }

    function displayPreviousScans(scans) {
      const scansList = document.getElementById('scansList');
      const previousScans = document.getElementById('previousScans');

      scansList.innerHTML = '';

      scans.forEach(scan => {
        const thumbnail = scan.has_thumbnail
          ? `<img src="${scan.thumbnail_url}" class="card-img-top" style="height: 120px; object-fit: cover;">`
          : `<div class="card-img-top bg-dark d-flex align-items-center justify-content-center" style="height: 120px; color: #999;">No thumbnail</div>`;

        const col = document.createElement('div');
        col.className = 'col-sm-6 col-md-4 col-lg-3';
        col.innerHTML = `
          <div class="card h-100 cursor-pointer" style="cursor: pointer; transition: transform 0.2s;">
            ${thumbnail}
            <div class="card-body">
              <h6 class="card-title small fw-bold text-truncate">${scan.scan_id} (${scan.duration}s)</h6>
              <p class="card-text small text-muted">${scan.packet_count} packets | ${scan.frame_count} frames</p>
            </div>
          </div>
        `;

        const card = col.querySelector('.card');
        card.addEventListener('mouseover', () => card.style.transform = 'scale(1.05)');
        card.addEventListener('mouseout', () => card.style.transform = 'scale(1)');
        card.addEventListener('click', () => {
          loadScanData(scan.host, scan.scan_id);
        });

        scansList.appendChild(col);
      });

      // Show previous scans section
      previousScans.classList.remove('d-none');
    }

    // Show previous scans after results are displayed
    function showPreviousScansSection() {
      const previousScans = document.getElementById('previousScans');
      previousScans.classList.remove('d-none');
    }

    async function loadScanData(host, scanId) {
      try {
        document.getElementById('results').classList.add('d-none');
        document.getElementById('errorMsg').classList.add('d-none');

        const response = await fetch('/api/load-scan?host=' + encodeURIComponent(host) + '&scan_id=' + encodeURIComponent(scanId));

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Failed to load scan');
        }

        const data = await response.json();
        displayResults(data);

        // Update URL to include scan identifier
        const newUrl = '?host=' + encodeURIComponent(host) + '&scan_id=' + encodeURIComponent(scanId);
        window.history.pushState({ host: host, scan_id: scanId }, '', newUrl);
      } catch (error) {
        showError('Failed to load scan: ' + error.message);
      }
    }

    async function reparseData() {
      const params = new URLSearchParams(window.location.search);
      const host = params.get('host');
      const scanId = params.get('scan_id');

      if (!host || !scanId) {
        showError('No scan loaded. Please load a scan first.');
        return;
      }

      try {
        const statusEl = document.getElementById('reparseStatus');
        statusEl.textContent = 'Reparsing...';
        statusEl.style.display = 'inline';

        const response = await fetch('/api/reparse?host=' + encodeURIComponent(host) + '&scan_id=' + encodeURIComponent(scanId), {
          method: 'POST'
        });

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Failed to reparse');
        }

        const result = await response.json();
        statusEl.textContent = 'Reparse complete! Reloading...';

        // Reload the scan data
        setTimeout(() => {
          loadScanData(host, scanId);
          // Clear status message after reload
          setTimeout(() => {
            statusEl.style.display = 'none';
          }, 500);
        }, 1000);
      } catch (error) {
        showError('Failed to reparse: ' + error.message);
        document.getElementById('reparseStatus').style.display = 'none';
      }
    }

    </script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  </body>
</html>
